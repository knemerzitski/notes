type PublicUserProfile {
  "User-friendly way to distinguish this user. Can be anything set by the user."
  displayName: String!
}

type PublicUserProfilePatch {
  "User display name has changed"
  displayName: String
}

"""
User info that the user itself can access
"""
type SignedInUser {
  "Self-descriptive"
  id: ID!
  "Self-descriptive"
  publicProfile: PublicUserProfile!
}

type SignedInUserPatch {
  "PublicUser.id that was patched"
  id: String!
  "Self-descriptive"
  publicProfile: PublicUserProfilePatch
}

"""
User info that might be accessed by any other user
"""
type PublicUser {
  "Self-descriptive"
  id: ObjectID!
  "Self-descriptive"
  profile: PublicUserProfile!
}

type PublicUserPatch {
  "PublicUser.id that was patched"
  id: String!
  "Self-descriptive"
  profile: PublicUserProfilePatch
}

################################ Update User Display Name ################################

input UpdateUserDisplayNameInput {
  "SignedInUser.id to update"
  userId: ObjectID!
  "New value for display name"
  displayName: String!
}

type UpdateUserDisplayNamePayload {
  "New updated display name"
  displayName: String!
  "User after setting new display name"
  signedInUser: SignedInUser!
}

extend type Mutation {
  updateUserDisplayName(input: UpdateUserDisplayNameInput): UpdateUserDisplayNamePayload!
}

################################ Query User ################################

extend type Query {
  "Get info about currently signed in user"
  signedInUser: SignedInUser! @auth
}

################################ Sign In ################################

enum AuthProvider {
  GOOGLE
}

"User info that is only available during sign in process and is not stored in database."
type AuthProviderUser {
  "User ID"
  id: ID!
  "User email. Not stored in database and only available after sign in."
  email: String!
}

input CredentialsInput {
  token: String!
}

input SignInInput {
  provider: AuthProvider!
  credentials: CredentialsInput!
}

type SignInPayload {
  "Signed in user"
  signedInUser: SignedInUser!
  "User info available only during sign in from auth provider"
  authProviderUser: AuthProviderUser!
}

extend type Mutation {
  "Returns null on failed sign in."
  signIn(input: SignInInput!): SignInPayload
}

################################ Sign Out ################################

"Sign out of current session unless allSessions or sessionId is specified"
input SignOutInput {
  "Sign out all users. Cookies are cleared."
  allUsers: Boolean
  "Sign out a specific user. This has no effect if allUsers is true."
  userId: String
}

type SignOutPayload {
  "Signin out is successful"
  signedOut: Boolean!
}

extend type Mutation {
  "Returns signed out http-conly cookie session index or null if user was not signed in."
  signOut(input: SignOutInput): SignOutPayload!
}

################################ Sync Session Cookies ################################

input SyncSessionCookiesInput {
  "Available user IDs for client."
  availableUserIds: [String!]!
}

type SyncSessionCookiesPayload {
  "User IDs available in http-only cookies. Any missing ID from input can be considered as an expired session."
  availableUserIds: [String!]!
}

extend type Mutation {
  "Call when session cookies are in invalid state. Server will fix cookies by setting new headers."
  syncSessionCookies(input: SyncSessionCookiesInput!): SyncSessionCookiesPayload!
}
