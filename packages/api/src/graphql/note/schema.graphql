input CreateNoteTextFieldEntryInput {
  "Note text field type. Either title or content."
  key: NoteTextField!
  "Actual value of text field."
  value: CreateCollabTextInput!
}

type NoteTextFieldEntry {
  "Note text field type. Either title or content."
  key: NoteTextField!
  "Actual value of text field."
  value: CollabText!
}

type NoteTextFieldEntryPatch {
  "Self-descriptive"
  key: NoteTextField!
  "Self-descriptive"
  value: CollabTextPatch!
}

input NoteTextFieldEntryPatchInput {
  key: NoteTextField!
  value: CollabTextPatchInput!
}

enum NoteTextField {
  TITLE
  CONTENT
}

type Note implements Node {
  "ID that globally identifies any note for any user."
  id: ID!
  "ID that identifies note by content. Used for querying."
  noteId: String!
  "All available text fields"
  textFields: [NoteTextFieldEntry!]!
  "Note read-only state. Default is false"
  readOnly: Boolean
  "Note preferences such as background color"
  preferences: NotePreferences
}

type NotePatch {
  "Changed note text fields"
  textFields: [NoteTextFieldEntryPatch!]
  "Changed preferences"
  preferences: NotePreferencesPatch
}

input NotePatchInput {
  textFields: [NoteTextFieldEntryPatchInput!]
  preferences: NotePreferencesPatchInput
}

input CreateNotePatchInput {
  "Initial note text fields"
  textFields: [CreateNoteTextFieldEntryInput!]
  preferences: NotePreferencesPatchInput
}

type NotePreferences {
  "Note background color"
  backgroundColor: HexColorCode
}

type NotePreferencesPatch {
  "Changed note background color"
  backgroundColor: HexColorCode
}

input NotePreferencesPatchInput {
  backgroundColor: HexColorCode
}

type NoteConnection implements Connection {
  "Notes directly without edges"
  notes: [Note]!
  "Self descriptive"
  edges: [NoteEdge]!
  "Self descriptive"
  pageInfo: PageInfo!
}

type NoteEdge implements Edge {
  "Self descriptive"
  node: Note!
  "Self descriptive"
  cursor: Cursor!
}

extend type Query {
  "Paginate notes."
  notesConnection(
    first: NonNegativeInt
    after: String
    last: NonNegativeInt
    before: String
  ): NoteConnection! @auth
  "Get note by content (Note.noteId value)"
  note(noteId: String!): Note! @auth
}

input CreateNoteInput {
  note: CreateNotePatchInput
}
type CreateNotePayload {
  "Created note"
  note: Note!
}
extend type Mutation {
  "Create a new note"
  createNote(input: CreateNoteInput!): CreateNotePayload @auth
}

input UpdateNoteInput {
  id: String!
  patch: NotePatchInput
}
type UpdateNotePayload {
  "ID of updated note"
  id: String!
  "Response patch to input"
  patch: NotePatch
}
extend type Mutation {
  "Update note"
  updateNote(input: UpdateNoteInput!): UpdateNotePayload! @auth
}

input DeleteNoteInput {
  id: String!
}
type DeleteNotePayload {
  "Self-descriptive"
  deleted: Boolean!
}
extend type Mutation {
  "Delete note by ID"
  deleteNote(input: DeleteNoteInput!): DeleteNotePayload! @auth
}

type NoteCreatedPayload {
  "Created note info"
  note: Note!
}
extend type Subscription {
  "A new note was created for current user"
  noteCreated: NoteCreatedPayload! @auth
}

input NoteUpdatedInput {
  "Note ID to subscribe for updates"
  id: String!
}
type NoteUpdatedPayload {
  "ID of note that was updated"
  id: String!
  "Changes made to the note"
  patch: NotePatch!
}
extend type Subscription {
  "An existing note was updated"
  noteUpdated(input: NoteUpdatedInput!): NoteUpdatedPayload! @auth
}

input NoteDeletedInput {
  "Note ID to subscribe for deletions"
  id: String!
}
type NoteDeletedPayload {
  "ID of deleted note"
  id: String!
}

extend type Subscription {
  "A note was deleted"
  noteDeleted(input: NoteDeletedInput!): NoteDeletedPayload! @auth
}
