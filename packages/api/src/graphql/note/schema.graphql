################################ Note ################################

type Note implements Node {
  "Globally identifies note over multiple users"
  id: ID!
  "Identifies note by text. Different users can have same noteId."
  # eslint-disable-next-line @graphql-eslint/no-typename-prefix
  noteId: ObjectID!
  "Read-only note text cannot be modified. Default is false."
  readOnly: Boolean
  "Date and time when note was created."
  createdAt: DateTime!
}

type NotePatch {
  "This patch applies to Note.id"
  id: String!
}

################################ Create Note ################################

input CreateNoteInput {
  "Ignore this field. It's a placeholder until the type is extended"
  # eslint-disable-next-line @graphql-eslint/naming-convention
  _: Boolean
}

type CreateNotePayload {
  "Created note"
  note: Note!
}

extend type Mutation {
  "Create a new note"
  createNote(input: CreateNoteInput!): CreateNotePayload @auth
}

################################ Delete Note ################################

type DeletedNote {
  "Deleted note ID"
  id: String!
}

input DeleteNoteInput {
  "Note to be deleted by Note.noteId"
  noteId: ObjectID!
}

type DeleteNotePayload {
  "Available note info after deletion"
  note: DeletedNote!
}

extend type Mutation {
  "Delete note permanently. Cannot be undone."
  deleteNote(input: DeleteNoteInput!): DeleteNotePayload! @auth
}

################################ Query Notes ################################

type NoteConnection implements Connection {
  "Notes directly without edges"
  notes: [Note!]!
  "Self descriptive"
  edges: [NoteEdge!]!
  "Self descriptive"
  pageInfo: PageInfo!
}

type NoteEdge implements Edge {
  "Self descriptive"
  node: Note!
  "Self descriptive"
  cursor: Cursor!
}

extend type Query {
  "Paginate notes by category. Default is NoteCategory.DEFAULT"
  noteConnection(
    first: NonNegativeInt
    after: String
    last: NonNegativeInt
    before: String
    category: NoteCategory
  ): NoteConnection! @auth
  "Get note by Note.noteId"
  note(noteId: ObjectID!): Note! @auth
  "Search for notes by text"
  noteSearchConnection(
    searchText: String!
    first: NonNegativeInt
    after: String
    last: NonNegativeInt
    before: String
  ): NoteConnection! @auth
}

################################ Note Users ################################

type NoteUser {
  "Self-descriptive"
  user: PublicUser!
  "This user has higher scope than current user"
  higherScope: Boolean!
  "This user has read-only access to the note"
  readOnly: Boolean!
}

type NoteUserPatch {
  "Patch applies to this user"
  user: PublicUserPatch!
  "User scope status changed"
  higherScope: Boolean
}

extend type Note {
  "All users (including yourself) who have access to the note"
  users: [NoteUser!]!
}

extend type NotePatch {
  "Changes made to users"
  users: [NoteUserPatch!]
  "List of PublicUser.ids that have been deleted from note. If current user is in list then note is no longer accessible."
  usersDeleted: [String!]
}

input UpdateNoteDeleteUserInput {
  "Affected note Note.id"
  noteId: ObjectID!
  "PublicUser.id to be deleted"
  userId: ObjectID!
}

type UpdateNoteDeleteUserPayload {
  "PublicUser.id of deleted user"
  userId: ObjectID!
}

input UpdateNoteSetUserReadOnlyInput {
  "Affected note Note.id"
  noteId: ObjectID!
  "PublicUser.id to update"
  userId: ObjectID!
  "Change user's access to note"
  readOnly: Boolean!
}

type UpdateNoteSetUserReadOnlyPayload {
  "New read-only value of user"
  readOnly: Boolean!
  "User with updated read-only value"
  user: NoteUser!
  "Note with updated users list"
  note: Note!
}

extend type Mutation {
  "Delete user from accessing the note"
  updateNoteDeleteUser(input: UpdateNoteDeleteUserInput!): UpdateNoteDeleteUserPayload!
  "Change user note permissions"
  updateNoteSetUserReadOnly(
    input: UpdateNoteSetUserReadOnlyInput!
  ): UpdateNoteSetUserReadOnlyPayload!
}

################################ Note Events Create/Update/Delete Subscriptions ################################

type NoteCreatedEvent {
  "Newly created note"
  note: Note!
}

type NoteUpdatedEvent {
  "Changes made to the note by patch"
  note: NotePatch!
}

type NoteDeletedEvent {
  "Info of deleted note"
  note: DeletedNote!
}

union NoteEvent = NoteCreatedEvent | NoteUpdatedEvent | NoteDeletedEvent

type NoteEventsPayload {
  "A list of notes events"
  events: [NoteEvent!]
}

extend type Subscription {
  "Subscribe to all note events related to current user"
  noteEvents: NoteEventsPayload! @auth
}

################################ Note Text Fields ################################

extend type Note {
  "All available text fields. If name is defined then only that field is returned."
  textFields(name: NoteTextField): [NoteTextFieldEntry!]!
}

extend type NotePatch {
  "Changed note text fields"
  textFields: [NoteTextFieldEntryPatch!]
}

extend input CreateNoteInput {
  "Initial note text fields"
  textFields: [CreateNoteTextFieldEntryInput!]
}

input CreateNoteTextFieldEntryInput {
  "Type of text field"
  key: NoteTextField!
  "Actual value of text field"
  value: CreateCollabTextInput!
}

type NoteTextFieldEntry {
  "Type of text field"
  key: NoteTextField!
  "Actual value of text field"
  value: CollabText!
}

type NoteTextFieldEntryPatch {
  "Type of text field"
  key: NoteTextField!
  "Actual value of text field"
  value: CollabTextPatch!
}

enum NoteTextField {
  TITLE
  CONTENT
}

input UpdateNoteTextFieldInsertRecordInput {
  "Note to be updated by Note.noteId"
  noteId: ObjectID!
  "Text field where to insert record"
  textField: NoteTextField!
  "New record to be inserted"
  insertRecord: CollabTextRecordInput!
}

type UpdateNoteTextFieldInsertRecordPayload {
  """
  New record added to text field. Could be an existing record that has
  previously been inserted. Check isExistingRecord field.
  """
  newRecord: CollabTextRecord!
  "True if record has already been inserted before."
  isExistingRecord: Boolean!
  "Text field that was updated"
  textField: NoteTextField!
  "Note after new record is inserted"
  note: Note!
}

extend type Mutation {
  "Insert new record to text field"
  updateNoteTextFieldInsertRecord(
    input: UpdateNoteTextFieldInsertRecordInput!
  ): UpdateNoteTextFieldInsertRecordPayload! @auth
}

################################ Note Trash/Untrash ################################

extend type Note {
  "Note is marked for deletion and will no longer be available after this date."
  deletedAt: DateTime
}

extend type NotePatch {
  "Note has been trashed and will be deleted after this date."
  deletedAt: DateTime
}

input TrashNoteInput {
  "Note to be trashed by Note.noteId"
  noteId: ObjectID!
}

type TrashNotePayload {
  "Time when note is permanently deleted from trash"
  deletedAt: DateTime!
  "Note after it's been trashed."
  note: Note!
}

extend type Mutation {
  "Trash note by ID. It can still be recovered by untrashing the note"
  trashNote(input: TrashNoteInput!): TrashNotePayload! @auth
}

################################ Note Category/Move ################################

extend type Note {
  "Category where note belongs"
  categoryName: NoteCategory!
}

extend type NotePatch {
  "Changed note category"
  categoryName: NoteCategory
  "Changed note location"
  location: NoteLocation
}

extend input CreateNoteInput {
  categoryName: NoteCategory
}

"""
All note categories
"""
enum NoteCategory {
  DEFAULT
  STICKY
  ARCHIVE
  TRASH
}

"""
Notes in these categories can be moved/reordered
"""
enum MovableNoteCategory {
  DEFAULT
  STICKY
  ARCHIVE
}

"""
Move notes between categories or withing category using anchor note.
"""
input NoteLocationInput {
  "Category where to put or keep the note."
  categoryName: MovableNoteCategory!
  """
  Note.noteId to be defined as anchor.
  If anchor note doesn't exist then anchor is ignored note is appended to the end.
  """
  anchorNoteId: ObjectID
  "How note is moved relative to anchor note"
  anchorPosition: ListAnchorPosition
}

type NoteLocation {
  "Note category after moving"
  categoryName: MovableNoteCategory!
  "Note position relative to anchor"
  anchorNote: Note
  "How note is positioned relative to anchorNote. Default is BEFORE"
  anchorPosition: ListAnchorPosition
}

enum ListAnchorPosition {
  AFTER
  BEFORE
}

input MoveNoteInput {
  "Note to be moved by Note.noteId"
  noteId: ObjectID!
  "Specify how to move the note. Undefined location can be used to move note out of trash back to original category."
  location: NoteLocationInput
}

type MoveNotePayload {
  "How note was moved"
  location: NoteLocation!
  "Note after the move"
  note: Note!
}

extend type Mutation {
  "Move note between categories or reorder within categories"
  moveNote(input: MoveNoteInput!): MoveNotePayload! @auth
}

################################ Note Preferences ################################

extend type Note {
  "Note preferences. Only visible to current user."
  preferences: NotePreferences
}

extend type NotePatch {
  "Changed preferences"
  preferences: NotePreferencesPatch
}

extend input CreateNoteInput {
  preferences: NotePreferencesInput
}

type NotePreferences {
  "Note background color"
  backgroundColor: HexColorCode
}

type NotePreferencesPatch {
  "Changed note background color"
  backgroundColor: HexColorCode
}

input NotePreferencesInput {
  backgroundColor: HexColorCode
}

input UpdateNoteBackgroundColorInput {
  "Note to be updated by Note.noteId"
  noteId: ObjectID!
  "New background color value"
  backgroundColor: HexColorCode!
}

type UpdateNoteBackgroundColorPayload {
  "Direct access to new background color"
  backgroundColor: HexColorCode!
  "Note after new background color is applied"
  note: Note!
}

extend type Mutation {
  "Update note preferences backgroundColor"
  updateNoteBackgroundColor(
    input: UpdateNoteBackgroundColorInput!
  ): UpdateNoteBackgroundColorPayload! @auth
}
